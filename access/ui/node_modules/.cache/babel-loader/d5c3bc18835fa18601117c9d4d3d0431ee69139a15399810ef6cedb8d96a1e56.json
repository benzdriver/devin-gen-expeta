{"ast":null,"code":"/**\n * @file WebSocketService.js\n * @description WebSocket服务，处理实时通信\n * \n * 需求:\n * 1. 建立和维护WebSocket连接\n * 2. 处理消息发送和接收\n * 3. 实现断线重连和心跳检测\n * 4. 提供会话状态变化的通知\n * 5. 支持生成进度的实时更新\n * \n * 主要方法:\n * - connect(token): 建立连接\n * - disconnect(): 断开连接\n * - sendMessage(message): 发送消息\n * - subscribe(eventType, callback): 订阅事件\n * - unsubscribe(subscription): 取消订阅\n */\n\n/**\n * WebSocket服务类\n */\nclass WebSocketService {\n  constructor(baseUrl) {\n    this.baseUrl = baseUrl || 'ws://localhost:8000/ws';\n    this.connection = null;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectTimeout = null;\n    this.pingInterval = null;\n    this.subscriptions = new Map();\n    this.eventListeners = new Map();\n    this.connectionPromise = null;\n    this.isConnecting = false;\n    this.token = null;\n  }\n\n  /**\n   * 初始化连接\n   * @param {string} token 认证令牌\n   * @returns {Promise} 连接Promise\n   */\n  connect(token) {\n    // 如果已连接或正在连接，返回现有Promise\n    if (this.connection && this.connection.readyState === WebSocket.OPEN) {\n      return Promise.resolve(this.connection);\n    }\n    if (this.isConnecting) {\n      return this.connectionPromise;\n    }\n    this.token = token;\n    this.isConnecting = true;\n\n    // 创建连接Promise\n    this.connectionPromise = new Promise((resolve, reject) => {\n      try {\n        const url = `${this.baseUrl}?token=${token}`;\n        this.connection = new WebSocket(url);\n        this.connection.onopen = () => {\n          console.log('WebSocket连接已建立');\n          this.reconnectAttempts = 0;\n          this.startPingInterval();\n          this.isConnecting = false;\n          resolve(this.connection);\n        };\n        this.connection.onclose = event => {\n          console.log(`WebSocket连接已关闭: ${event.code} ${event.reason}`);\n          this.stopPingInterval();\n          this.handleReconnect();\n\n          // 触发关闭事件\n          this.dispatchEvent('close', event);\n        };\n        this.connection.onerror = error => {\n          console.error('WebSocket错误:', error);\n          this.isConnecting = false;\n          reject(error);\n\n          // 触发错误事件\n          this.dispatchEvent('error', error);\n        };\n        this.connection.onmessage = event => {\n          this.handleMessage(event);\n        };\n      } catch (error) {\n        this.isConnecting = false;\n        reject(error);\n      }\n    });\n    return this.connectionPromise;\n  }\n\n  /**\n   * 断开连接\n   */\n  disconnect() {\n    if (this.connection) {\n      this.connection.close();\n      this.connection = null;\n    }\n    this.stopPingInterval();\n    this.clearReconnectTimeout();\n    this.subscriptions.clear();\n    this.isConnecting = false;\n    this.connectionPromise = null;\n  }\n\n  /**\n   * 发送消息\n   * @param {Object} message 消息对象\n   * @returns {Promise} 发送Promise\n   */\n  sendMessage(message) {\n    return this.ensureConnected().then(() => {\n      const messageString = typeof message === 'string' ? message : JSON.stringify(message);\n      this.connection.send(messageString);\n      return true;\n    });\n  }\n\n  /**\n   * 确保已连接\n   * @returns {Promise} 连接Promise\n   */\n  ensureConnected() {\n    if (this.connection && this.connection.readyState === WebSocket.OPEN) {\n      return Promise.resolve(this.connection);\n    }\n    return this.connect(this.token);\n  }\n\n  /**\n   * 处理接收到的消息\n   * @param {MessageEvent} event WebSocket消息事件\n   */\n  handleMessage(event) {\n    try {\n      const data = JSON.parse(event.data);\n\n      // 处理不同类型的消息\n      if (data.type === 'ping') {\n        // 响应ping消息\n        this.sendMessage({\n          type: 'pong'\n        });\n        return;\n      }\n\n      // 触发消息事件\n      this.dispatchEvent('message', data);\n\n      // 处理特定类型的消息\n      if (data.type) {\n        this.dispatchEvent(data.type, data);\n      }\n\n      // 通知订阅者\n      if (data.subscriptionId && this.subscriptions.has(data.subscriptionId)) {\n        const callback = this.subscriptions.get(data.subscriptionId);\n        callback(data);\n      }\n    } catch (error) {\n      console.error('处理消息失败:', error);\n    }\n  }\n\n  /**\n   * 处理重连\n   */\n  handleReconnect() {\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.log('达到最大重连次数，停止重连');\n      this.dispatchEvent('reconnectFailed');\n      return;\n    }\n    this.reconnectAttempts++;\n    const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);\n    console.log(`尝试重连 #${this.reconnectAttempts}，${delay}ms后...`);\n    this.clearReconnectTimeout();\n    this.reconnectTimeout = setTimeout(() => {\n      console.log(`开始第${this.reconnectAttempts}次重连尝试`);\n      this.connect(this.token).catch(() => {\n        // 重连失败，将由onclose事件触发下一次重连\n      });\n    }, delay);\n  }\n\n  /**\n   * 启动定时ping\n   */\n  startPingInterval() {\n    this.stopPingInterval();\n    this.pingInterval = setInterval(() => {\n      if (this.connection && this.connection.readyState === WebSocket.OPEN) {\n        this.sendMessage({\n          type: 'ping'\n        }).catch(() => {\n          // 发送ping失败，可能连接已断开\n          this.connection.close();\n        });\n      }\n    }, 30000); // 每30秒发送一次ping\n  }\n\n  /**\n   * 停止定时ping\n   */\n  stopPingInterval() {\n    if (this.pingInterval) {\n      clearInterval(this.pingInterval);\n      this.pingInterval = null;\n    }\n  }\n\n  /**\n   * 清除重连定时器\n   */\n  clearReconnectTimeout() {\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n  }\n\n  /**\n   * 订阅特定事件\n   * @param {string} eventType 事件类型\n   * @param {Function} callback 回调函数\n   * @returns {Object} 订阅对象\n   */\n  addEventListener(eventType, callback) {\n    if (!this.eventListeners.has(eventType)) {\n      this.eventListeners.set(eventType, new Set());\n    }\n    const listeners = this.eventListeners.get(eventType);\n    listeners.add(callback);\n    return {\n      remove: () => {\n        listeners.delete(callback);\n        if (listeners.size === 0) {\n          this.eventListeners.delete(eventType);\n        }\n      }\n    };\n  }\n\n  /**\n   * 触发事件\n   * @param {string} eventType 事件类型\n   * @param {any} data 事件数据\n   */\n  dispatchEvent(eventType, data) {\n    if (this.eventListeners.has(eventType)) {\n      const listeners = this.eventListeners.get(eventType);\n      listeners.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error(`事件处理器错误 (${eventType}):`, error);\n        }\n      });\n    }\n  }\n\n  /**\n   * 订阅会话更新\n   * @param {string} conversationId 会话ID\n   * @param {Function} callback 回调函数\n   * @returns {Object} 订阅对象\n   */\n  subscribeToConversation(conversationId, callback) {\n    const subscriptionId = `conversation:${conversationId}`;\n    return this.subscribe(subscriptionId, callback);\n  }\n\n  /**\n   * 订阅生成进度\n   * @param {string} generationId 生成ID\n   * @param {Function} callback 回调函数\n   * @returns {Object} 订阅对象\n   */\n  subscribeToGeneration(generationId, callback) {\n    const subscriptionId = `generation:${generationId}`;\n    return this.subscribe(subscriptionId, callback);\n  }\n\n  /**\n   * 订阅事件\n   * @param {string} subscriptionId 订阅ID\n   * @param {Function} callback 回调函数\n   * @returns {Object} 订阅对象\n   */\n  subscribe(subscriptionId, callback) {\n    this.subscriptions.set(subscriptionId, callback);\n\n    // 发送订阅消息\n    this.ensureConnected().then(() => {\n      this.sendMessage({\n        type: 'subscribe',\n        subscriptionId\n      });\n    });\n    return {\n      subscriptionId,\n      unsubscribe: () => this.unsubscribe(subscriptionId)\n    };\n  }\n\n  /**\n   * 取消订阅\n   * @param {string} subscriptionId 订阅ID\n   */\n  unsubscribe(subscriptionId) {\n    if (this.subscriptions.has(subscriptionId)) {\n      this.subscriptions.delete(subscriptionId);\n\n      // 发送取消订阅消息\n      if (this.connection && this.connection.readyState === WebSocket.OPEN) {\n        this.sendMessage({\n          type: 'unsubscribe',\n          subscriptionId\n        }).catch(() => {\n          // 忽略错误\n        });\n      }\n    }\n  }\n}\n\n// 创建全局单例\nconst webSocketService = new WebSocketService();\nexport default webSocketService;","map":{"version":3,"names":["WebSocketService","constructor","baseUrl","connection","reconnectAttempts","maxReconnectAttempts","reconnectTimeout","pingInterval","subscriptions","Map","eventListeners","connectionPromise","isConnecting","token","connect","readyState","WebSocket","OPEN","Promise","resolve","reject","url","onopen","console","log","startPingInterval","onclose","event","code","reason","stopPingInterval","handleReconnect","dispatchEvent","onerror","error","onmessage","handleMessage","disconnect","close","clearReconnectTimeout","clear","sendMessage","message","ensureConnected","then","messageString","JSON","stringify","send","data","parse","type","subscriptionId","has","callback","get","delay","Math","min","pow","setTimeout","catch","setInterval","clearInterval","clearTimeout","addEventListener","eventType","set","Set","listeners","add","remove","delete","size","forEach","subscribeToConversation","conversationId","subscribe","subscribeToGeneration","generationId","unsubscribe","webSocketService"],"sources":["/Users/ziyanzhou/Projects/devin-gen-expeta/access/ui/src/services/WebSocketService.js"],"sourcesContent":["/**\n * @file WebSocketService.js\n * @description WebSocket服务，处理实时通信\n * \n * 需求:\n * 1. 建立和维护WebSocket连接\n * 2. 处理消息发送和接收\n * 3. 实现断线重连和心跳检测\n * 4. 提供会话状态变化的通知\n * 5. 支持生成进度的实时更新\n * \n * 主要方法:\n * - connect(token): 建立连接\n * - disconnect(): 断开连接\n * - sendMessage(message): 发送消息\n * - subscribe(eventType, callback): 订阅事件\n * - unsubscribe(subscription): 取消订阅\n */\n\n/**\n * WebSocket服务类\n */\nclass WebSocketService {\n  constructor(baseUrl) {\n    this.baseUrl = baseUrl || 'ws://localhost:8000/ws';\n    this.connection = null;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectTimeout = null;\n    this.pingInterval = null;\n    this.subscriptions = new Map();\n    this.eventListeners = new Map();\n    this.connectionPromise = null;\n    this.isConnecting = false;\n    this.token = null;\n  }\n\n  /**\n   * 初始化连接\n   * @param {string} token 认证令牌\n   * @returns {Promise} 连接Promise\n   */\n  connect(token) {\n    // 如果已连接或正在连接，返回现有Promise\n    if (this.connection && this.connection.readyState === WebSocket.OPEN) {\n      return Promise.resolve(this.connection);\n    }\n    \n    if (this.isConnecting) {\n      return this.connectionPromise;\n    }\n    \n    this.token = token;\n    this.isConnecting = true;\n    \n    // 创建连接Promise\n    this.connectionPromise = new Promise((resolve, reject) => {\n      try {\n        const url = `${this.baseUrl}?token=${token}`;\n        this.connection = new WebSocket(url);\n        \n        this.connection.onopen = () => {\n          console.log('WebSocket连接已建立');\n          this.reconnectAttempts = 0;\n          this.startPingInterval();\n          this.isConnecting = false;\n          resolve(this.connection);\n        };\n        \n        this.connection.onclose = (event) => {\n          console.log(`WebSocket连接已关闭: ${event.code} ${event.reason}`);\n          this.stopPingInterval();\n          this.handleReconnect();\n          \n          // 触发关闭事件\n          this.dispatchEvent('close', event);\n        };\n        \n        this.connection.onerror = (error) => {\n          console.error('WebSocket错误:', error);\n          this.isConnecting = false;\n          reject(error);\n          \n          // 触发错误事件\n          this.dispatchEvent('error', error);\n        };\n        \n        this.connection.onmessage = (event) => {\n          this.handleMessage(event);\n        };\n      } catch (error) {\n        this.isConnecting = false;\n        reject(error);\n      }\n    });\n    \n    return this.connectionPromise;\n  }\n\n  /**\n   * 断开连接\n   */\n  disconnect() {\n    if (this.connection) {\n      this.connection.close();\n      this.connection = null;\n    }\n    \n    this.stopPingInterval();\n    this.clearReconnectTimeout();\n    this.subscriptions.clear();\n    this.isConnecting = false;\n    this.connectionPromise = null;\n  }\n\n  /**\n   * 发送消息\n   * @param {Object} message 消息对象\n   * @returns {Promise} 发送Promise\n   */\n  sendMessage(message) {\n    return this.ensureConnected().then(() => {\n      const messageString = typeof message === 'string' ? \n        message : JSON.stringify(message);\n      \n      this.connection.send(messageString);\n      return true;\n    });\n  }\n\n  /**\n   * 确保已连接\n   * @returns {Promise} 连接Promise\n   */\n  ensureConnected() {\n    if (this.connection && this.connection.readyState === WebSocket.OPEN) {\n      return Promise.resolve(this.connection);\n    }\n    \n    return this.connect(this.token);\n  }\n\n  /**\n   * 处理接收到的消息\n   * @param {MessageEvent} event WebSocket消息事件\n   */\n  handleMessage(event) {\n    try {\n      const data = JSON.parse(event.data);\n      \n      // 处理不同类型的消息\n      if (data.type === 'ping') {\n        // 响应ping消息\n        this.sendMessage({ type: 'pong' });\n        return;\n      }\n      \n      // 触发消息事件\n      this.dispatchEvent('message', data);\n      \n      // 处理特定类型的消息\n      if (data.type) {\n        this.dispatchEvent(data.type, data);\n      }\n      \n      // 通知订阅者\n      if (data.subscriptionId && this.subscriptions.has(data.subscriptionId)) {\n        const callback = this.subscriptions.get(data.subscriptionId);\n        callback(data);\n      }\n    } catch (error) {\n      console.error('处理消息失败:', error);\n    }\n  }\n\n  /**\n   * 处理重连\n   */\n  handleReconnect() {\n    if (this.reconnectAttempts >= this.maxReconnectAttempts) {\n      console.log('达到最大重连次数，停止重连');\n      this.dispatchEvent('reconnectFailed');\n      return;\n    }\n    \n    this.reconnectAttempts++;\n    const delay = Math.min(1000 * Math.pow(2, this.reconnectAttempts), 30000);\n    \n    console.log(`尝试重连 #${this.reconnectAttempts}，${delay}ms后...`);\n    this.clearReconnectTimeout();\n    \n    this.reconnectTimeout = setTimeout(() => {\n      console.log(`开始第${this.reconnectAttempts}次重连尝试`);\n      this.connect(this.token).catch(() => {\n        // 重连失败，将由onclose事件触发下一次重连\n      });\n    }, delay);\n  }\n\n  /**\n   * 启动定时ping\n   */\n  startPingInterval() {\n    this.stopPingInterval();\n    this.pingInterval = setInterval(() => {\n      if (this.connection && this.connection.readyState === WebSocket.OPEN) {\n        this.sendMessage({ type: 'ping' }).catch(() => {\n          // 发送ping失败，可能连接已断开\n          this.connection.close();\n        });\n      }\n    }, 30000); // 每30秒发送一次ping\n  }\n\n  /**\n   * 停止定时ping\n   */\n  stopPingInterval() {\n    if (this.pingInterval) {\n      clearInterval(this.pingInterval);\n      this.pingInterval = null;\n    }\n  }\n\n  /**\n   * 清除重连定时器\n   */\n  clearReconnectTimeout() {\n    if (this.reconnectTimeout) {\n      clearTimeout(this.reconnectTimeout);\n      this.reconnectTimeout = null;\n    }\n  }\n\n  /**\n   * 订阅特定事件\n   * @param {string} eventType 事件类型\n   * @param {Function} callback 回调函数\n   * @returns {Object} 订阅对象\n   */\n  addEventListener(eventType, callback) {\n    if (!this.eventListeners.has(eventType)) {\n      this.eventListeners.set(eventType, new Set());\n    }\n    \n    const listeners = this.eventListeners.get(eventType);\n    listeners.add(callback);\n    \n    return {\n      remove: () => {\n        listeners.delete(callback);\n        if (listeners.size === 0) {\n          this.eventListeners.delete(eventType);\n        }\n      }\n    };\n  }\n\n  /**\n   * 触发事件\n   * @param {string} eventType 事件类型\n   * @param {any} data 事件数据\n   */\n  dispatchEvent(eventType, data) {\n    if (this.eventListeners.has(eventType)) {\n      const listeners = this.eventListeners.get(eventType);\n      listeners.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error(`事件处理器错误 (${eventType}):`, error);\n        }\n      });\n    }\n  }\n\n  /**\n   * 订阅会话更新\n   * @param {string} conversationId 会话ID\n   * @param {Function} callback 回调函数\n   * @returns {Object} 订阅对象\n   */\n  subscribeToConversation(conversationId, callback) {\n    const subscriptionId = `conversation:${conversationId}`;\n    return this.subscribe(subscriptionId, callback);\n  }\n\n  /**\n   * 订阅生成进度\n   * @param {string} generationId 生成ID\n   * @param {Function} callback 回调函数\n   * @returns {Object} 订阅对象\n   */\n  subscribeToGeneration(generationId, callback) {\n    const subscriptionId = `generation:${generationId}`;\n    return this.subscribe(subscriptionId, callback);\n  }\n\n  /**\n   * 订阅事件\n   * @param {string} subscriptionId 订阅ID\n   * @param {Function} callback 回调函数\n   * @returns {Object} 订阅对象\n   */\n  subscribe(subscriptionId, callback) {\n    this.subscriptions.set(subscriptionId, callback);\n    \n    // 发送订阅消息\n    this.ensureConnected().then(() => {\n      this.sendMessage({\n        type: 'subscribe',\n        subscriptionId\n      });\n    });\n    \n    return {\n      subscriptionId,\n      unsubscribe: () => this.unsubscribe(subscriptionId)\n    };\n  }\n\n  /**\n   * 取消订阅\n   * @param {string} subscriptionId 订阅ID\n   */\n  unsubscribe(subscriptionId) {\n    if (this.subscriptions.has(subscriptionId)) {\n      this.subscriptions.delete(subscriptionId);\n      \n      // 发送取消订阅消息\n      if (this.connection && this.connection.readyState === WebSocket.OPEN) {\n        this.sendMessage({\n          type: 'unsubscribe',\n          subscriptionId\n        }).catch(() => {\n          // 忽略错误\n        });\n      }\n    }\n  }\n}\n\n// 创建全局单例\nconst webSocketService = new WebSocketService();\n\nexport default webSocketService;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}